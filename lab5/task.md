### **Лабораторная работа №3: Применение паттернов проектирования в системе учета сотрудников**

**Цель работы:** Освоить практическое применение паттернов проектирования для рефакторинга и улучшения кодовой базы системы учета сотрудников. Получить навыки применения различных паттернов для решения типичных задач проектирования ПО.

**Стек технологий:**
*   **Язык программирования:** Python 3.x
*   **База данных:** SQLite (опционально)
*   **Дополнительные библиотеки:** `abc`, `json`, `sqlite3`
*   **Инструменты:** Любая IDE, Git

**Теоретическая часть:**
Паттерны проектирования — это типичные способы решения часто встречающихся проблем в проектировании ПО. В данной работе рассматриваются:

1.  **Порождающие паттерны:** Singleton, Factory Method, Abstract Factory, Builder
2.  **Структурные паттерны:** Adapter, Decorator, Facade
3.  **Поведенческие паттерны:** Observer, Strategy, Command

---

### **Задание на практическую реализацию:**

Работа представляет собой комплексный рефакторинг системы из ЛР №2 с применением 10+ паттернов проектирования.

#### **Часть 1: Порождающие паттерны**

**1.1. Singleton (Одиночка)**
*   **Задача:** Создать класс `DatabaseConnection` для управления подключением к БД SQLite.
*   **Требования:** Гарантировать единственное подключение к БД в рамках приложения.
*   **Методы:** `get_connection()`, `close_connection()`
*   **Демонстрация:** Показать, что多次ное создание объекта возвращает один и тот же экземпляр.

**1.2. Factory Method (Фабричный метод)**
*   **Задача:** Рефакторинг существующей `EmployeeFactory` из ЛР №2.
*   **Требования:** Создать абстрактный класс `EmployeeFactory` с методом `create_employee()`. Реализовать конкретные фабрики для каждого типа сотрудников.
*   **Демонстрация:** Создание сотрудников через специализированные фабрики.

**1.3. Abstract Factory (Абстрактная фабрика)**
*   **Задача:** Создать фабрики для разных типов компаний (`TechCompanyFactory`, `SalesCompanyFactory`).
*   **Требования:** Каждая фабрика создает согласованный набор объектов (специфических сотрудников, отделов, проектов).
*   **Демонстрация:** Создание различных компаний с помощью разных фабрик.

**1.4. Builder (Строитель)**
*   **Задача:** Создать `EmployeeBuilder` для пошагового создания сложных объектов сотрудников.
*   **Требования:** Реализовать fluent-интерфейс. Возможность создания сотрудников с различными опциональными параметрами.
*   **Демонстрация:** Построение объектов с разными конфигурациями.

#### **Часть 2: Структурные паттерны**

**2.1. Adapter (Адаптер)**
*   **Задача:** Создать адаптер для интеграции с внешней системой расчета зарплат.
*   **Требования:** Адаптировать интерфейс внешней библиотеки к интерфейсу нашей системы.
*   **Демонстрация:** Использование адаптера для расчета зарплат.

**2.2. Decorator (Декоратор)**
*   **Задача:** Создать декораторы для добавления дополнительной функциональности сотрудникам.
*   **Требования:** Реализовать декораторы `BonusDecorator`, `TrainingDecorator` которые добавляют новые возможности существующим объектам.
*   **Демонстрация:** Динамическое добавление новой функциональности.

**2.3. Facade (Фасад)**
*   **Задача:** Создать упрощенный интерфейс для работы с сложной системой компании.
*   **Требования:** Класс `CompanyFacade` с методами для основных операций (найм, увольнение, расчет зарплат).
*   **Демонстрация:** Упрощение работы с комплексной системой.

#### **Часть 3: Поведенческие паттерны**

**3.1. Observer (Наблюдатель)**
*   **Задача:** Реализовать систему уведомлений об изменениях в системе.
*   **Требования:** Создать `NotificationSystem` с методами подписки/отписки. Уведомлять о изменениях зарплат, статусов проектов.
*   **Демонстрация:** Работа системы уведомлений.

**3.2. Strategy (Стратегия)**
*   **Задача:** Реализовать различные стратегии расчета бонусов.
*   **Требования:** Создать интерфейс `BonusStrategy` с реализациями `PerformanceBonus`, `SeniorityBonus`, `ProjectBonus`.
*   **Демонстрация:** Динамическая смена стратегий расчета.

**3.3. Command (Команда)**
*   **Задача:** Реализовать систему команд для операций с сотрудниками.
*   **Требования:** Создать команды `HireEmployeeCommand`, `FireEmployeeCommand`, `UpdateSalaryCommand`. Реализовать механизм отмены операций.
*   **Демонстрация:** Выполнение и отмена команд.

#### **Часть 4: Комбинированные паттерны**

**4.1. Repository Pattern**
*   **Задача:** Создать репозитории для работы с данными.
*   **Требования:** `EmployeeRepository`, `DepartmentRepository` с методами CRUD.
*   **Демонстрация:** Работа с данными через репозитории.

**4.2. Unit of Work**
*   **Задача:** Реализовать паттерн Unit of Work для управления транзакциями.
*   **Требования:** Гарантия согласованности данных при комплексных операциях.
*   **Демонстрация:** Транзакционные операции.

**4.3. Specification Pattern**
*   **Задача:** Реализовать паттерн Спецификация для фильтрации сотрудников.
*   **Требования:** Создать спецификации `SalarySpecification`, `DepartmentSpecification`, `SkillSpecification`.
*   **Демонстрация:** Построение сложных запросов.

#### **Часть 5: Тестирование и демонстрация**

**5.1. Комплексный пример**
```python
def demonstrate_patterns():
    # 1. Singleton
    db1 = DatabaseConnection.get_instance()
    db2 = DatabaseConnection.get_instance()
    print(f"Singleton test: {db1 is db2}")
    
    # 2. Abstract Factory
    tech_factory = TechCompanyFactory()
    tech_company = tech_factory.create_company("TechCorp")
    
    # 3. Builder
    developer = (EmployeeBuilder()
                .set_id(101)
                .set_name("John Doe")
                .set_department("DEV")
                .set_base_salary(5000)
                .set_skills(["Python", "Java"])
                .set_seniority("senior")
                .build())
    
    # 4. Observer
    notification_system = NotificationSystem()
    developer.add_observer(notification_system)
    
    # 5. Strategy
    bonus_strategy = PerformanceBonusStrategy()
    developer.set_bonus_strategy(bonus_strategy)
    
    # 6. Command
    hire_command = HireEmployeeCommand(developer, tech_company)
    hire_command.execute()
    
    # 7. Repository
    employee_repo = EmployeeRepository()
    employee_repo.add(developer)
    
    # 8. Specification
    high_salary_spec = SalarySpecification(min_salary=4000)
    dev_spec = DepartmentSpecification("DEV")
    combined_spec = high_salary_spec & dev_spec
    
    high_paid_devs = employee_repo.find_by_specification(combined_spec)
    print(f"High paid developers: {len(high_paid_devs)}")
```

**5.2. Требования к демонстрации:**
*   Показать работу каждого паттерна отдельно
*   Показать взаимодействие паттернов
*   Продемонстрировать преимущества после рефакторинга

#### **Требования к отчету:**

1.  **Код:** Полные исходные тексты всех классов с паттернами
2.  **Диаграммы:** UML-диаграммы ключевых паттернов
3.  **Сравнение:** Код до и после применения паттернов
4.  **Анализ:** Преимущества и недостатки каждого примененного паттерна
5.  **Тесты:** Юнит-тесты для основных функциональностей

#### **Критерии оценки:**

*   **Удовлетворительно:** Реализовано 3 паттернов с базовой функциональностью
*   **Хорошо:** Реализовано 4 паттернов с полной функциональностью
*   **Отлично:** Реализовано 5+ паттернов с комплексным взаимодействием и полной документацией

**Примечание:** Все паттерны должны быть применены к существующей кодобазе из ЛР ООП (основы), демонстрируя улучшение архитектуры и расширяемости системы.
