# Отчёт по лабораторной работе

**Тема:** Реализация принципов ООП на примере системы учета сотрудников

## Сведения о студенте

**Дата:** 2025-09-04  
**Семестр:** 2 курс, 1 полугодие (3 семестр)  
**Группа:** ПИН-б-о-24-1  
**Дисциплина:** Технологии программирования  
**Студент:** Куйбышев Александр Максимович  

### Цель работы

Разработка комплексной системы учета сотрудников компании с применением всех принципов объектно-ориентированного программирования.

### Структура проекта

```
lab4/
├── report.md
├── task.md
├── project/
│   ├── employee.py
│   ├── department.py
│   ├── project.py
│   └── company.py
└── report/
```
## Часть 4.1: Инкапсуляция

Реализация базового класса `Employee` с инкапсуляцией данных и валидацией.
Выполненные задачи

- Создан класс `Employee` с приватными атрибутами
- Реализованы свойства (property) для доступа к данным
- Добавлена валидация входных параметров
- Реализован метод `__str__` для строкового представления

Ключевые элементы реализации

```py
class Employee:
    def __init__(self, id: int, name: str, department: str, base_salary: float):
        self.__id = id
        self.__name = name
        self.__department = department
        self.__base_salary = base_salary
    
    @property
    def id(self):
        return self.__id
    
    @id.setter
    def id(self, value):
        if value <= 0:
            raise ValueError('ID должен быть положительным')
        self.__id = value
```
Результаты тестирования
- Протестирована корректная установка и получение значений
- Проверена обработка невалидных данных (выбрасываются исключения)
- Убедились в корректности строкового представления
#### Диаграмма классов

![UML Иерархия классов](report/diagram4_1)
## Часть 4.2: Наследование и абстракция

Создание иерархии классов сотрудников на основе наследования и абстракции.

#### Выполненные задачи
- Создан абстрактный класс AbstractEmployee
- Реализованы классы-наследники: Manager, Developer, Salesperson
- Реализована фабрика сотрудников EmployeeFactory
- Переопределены методы расчета зарплат

#### Диаграмма классов

![UML Иерархия классов](report/diagram4_2)
#### Пример использования

```python
manager = Manager(2, "Петр Петров", "Менеджмент", 70000, 20000)
developer = Developer(3, "Алексей Сидоров", "IT", 60000, 
                     ["Python", "Django"], "middle")

print(manager.calculate_salary())  # 90000.0
print(developer.calculate_salary()) # 90000.0
```
## Часть 4.3: Полиморфизм и магические методы

Реализация полиморфного поведения и перегрузки операторов.
#### Выполненные задачи
- Создан класс Department для управления сотрудниками
- Реализованы магические методы для сотрудников и отделов
- Добавлена поддержка сериализации/десериализации
- Реализована итерация по объектам

#### Примеры реализации

```python
def __add__(self, other) -> float:
    """Сложение двух сотрудников возвращает сумму их зарплат"""
    if not isinstance(other, AbstractEmployee):
        return NotImplemented
    return self.calculate_salary() + other.calculate_salary()

# Полиморфизм
for emp in department:
    print(f"  - {emp.get_info()}")
```
#### Диаграмма классов

![UML Department](report/diagram4_3)
## Часть 4.4: Композиция и агрегация

Построение сложных объектных структур с использованием композиции и агрегации.
#### Выполненные задачи
- Создан класс Project с композицией сотрудников
- Реализован класс Company с агрегацией отделов и проектов
- Добавлена система валидации и кастомные исключения
- Реализована комплексная сериализация системы

#### Примеры реализации

```python
class Project:
    VALID_STATUSES = ["planning", "active", "completed", "cancelled"]
    
    def __init__(self, project_id: int, name: str, description: str, 
                 deadline: str, status: str = "planning"):
        self.__project_id = project_id
        self.__name = name
        self.__description = description
        self.__deadline = self._parse_date(deadline)
        self.__status = status
        self.__team: List[AbstractEmployee] = []

    def add_team_member(self, employee: AbstractEmployee):
        self.__team.append(employee)
```
#### Диаграмма классов

![UML Композиция](report/diagram4_4)
## Выводы

1. ООП делает код гибким и понятным - абстракция и наследование помогают создавать иерархии объектов (сотрудники разных типов), композиция и агрегация управляют связями между ними (отделы, проекты).

2. Паттерны решают типовые проблемы - фабрика создает объекты, исключения обрабатывают ошибки, полиморфизм позволяет работать с разными объектами одинаково.

3. Хорошая архитектура экономит время - система с сериализацией, валидацией и отчетами из учебного примера становится готовым решением для реального учета сотрудников в компании.

## Список использованных источников

- [Документация Python](https://docs.python.org/3/)
- [PlantUML для UML-диаграмм](https://plantuml.com/ru/)
